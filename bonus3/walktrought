Nous analysons bonus3 avec gdb.

Deux variables avant le fopen, ou nous pouvons les lires en faisant p/s (char*) var

0x08048502 <+14>:    mov    $0x80486f0,%edx -> "r"
0x08048507 <+19>:    mov    $0x80486f2,%eax -> "/home/user/end/.pass"

Puis nous avons une condition, si jamais fopen est null ou si les arguments ne sont pas Ã©gale a deux, cela nous fait un return.
0x08048533 <+63>:    cmpl   $0x0,0x9c(%esp)
0x0804853b <+71>:    je     0x8048543 <main+79>
0x0804853d <+73>:    cmpl   $0x2,0x8(%ebp)
0x08048541 <+77>:    je     0x804854d <main+89>
0x08048543 <+79>:    mov    $0xffffffff,%eax
0x08048548 <+84>:    jmp    0x8048615 <main+289>

Puis nous avons un fread sur le file, qu'on stocke dans un buffer et ensuite nous faisons appel a la fonction atoi. Petit rappel, quand nous passons "" dans la fonction atoi, cela nous retourne 0
0x08048584 <+144>:   call   0x8048430 <atoi@plt>
0x08048589 <+149>:   movb   $0x0,0x18(%esp,%eax,1)

La ligne 149 nous indique que nous devons remplacer une valeur dans le tableau. Ce qui se traduit par ceci:
buffer[atoi(argv[1])] = 0; // $0x0(0), 0x18(buffer), %eax(atoi), %esp et 1 (argv[1]). Cette ligne, pas sur de moi donc n'hesite pas a la retirer.

Puis nous avons un second fread et fclose.
0x080485b3 <+191>:   call   0x80483d0 <fread@plt>
0x080485b8 <+196>:   mov    0x9c(%esp),%eax
0x080485bf <+203>:   mov    %eax,(%esp)
0x080485c2 <+206>:   call   0x80483c0 <fclose@plt>

Puis nous avons un appel a la fonction strcmp qui compare buffer et argv[1]. Donc nous comparons Buffer (buffer[0] = 0, rappellons nous) et "" ce qui nous retourne 0, et permet de lancer le shell.
0x080485da <+230>:   call   0x80483b0 <strcmp@plt>
0x080485df <+235>:   test   %eax,%eax

